from typing import List, Dict, Optional

from config import DEFAULT_CHUNK_SIZE, CHUNK_OVERLAP, MIN_CHUNK_SIZE
from .rag_models import EnrichedItem, RAGOutputItem


class Chunker:
    def __init__(self, logger,
                 max_chunk_size_chars: int = DEFAULT_CHUNK_SIZE,
                 min_chunk_size_chars: int = MIN_CHUNK_SIZE,
                 overlap_size_chars: int = CHUNK_OVERLAP):
        self.logger = logger
        self.max_chunk_size = max_chunk_size_chars
        self.min_chunk_size = min_chunk_size_chars
        self.overlap_size = overlap_size_chars

    def _create_rag_item(self, enriched_item: EnrichedItem, chunk_text: str,
                         chunk_idx: int, total_chunks_for_elem: int,
                         parent_type: str, parent_element_idx: Optional[int] = None,
                         element_specific_lang: Optional[str] = None,
                         element_specific_entities: Optional[List[Dict[str, str]]] = None
                         ) -> RAGOutputItem:
        """Helper to create a RAGOutputItem with propagated metadata."""
        return RAGOutputItem(
            parent_item_id=enriched_item.id,
            source_url=enriched_item.source_url,
            source_type=enriched_item.source_type,
            query_used=enriched_item.query_used,
            chunk_text=chunk_text.strip(),
            chunk_index=chunk_idx,
            chunk_parent_type=parent_type,
            chunk_parent_element_index=parent_element_idx,
            total_chunks_for_parent_element=total_chunks_for_elem,
            title=enriched_item.title,
            # Use element specific language if available, else parent's, else None
            language=element_specific_lang or enriched_item.language_of_primary_text,
            # Propagate categories and tags from parent item
            categories=enriched_item.categories,
            tags=enriched_item.tags,
            # Entities specific to this chunk (could be refined if enricher does per-chunk NER)
            entities_in_chunk=element_specific_entities or enriched_item.overall_entities[:5],
            # Show some overall entities for now
            quality_score=enriched_item.quality_score,
            # Timestamp is auto-generated by RAGOutputItem model
        )

    def _chunk_single_content_piece(self, content: str, enriched_item: EnrichedItem,
                                    parent_type: str, parent_element_idx: Optional[int] = None,
                                    element_lang: Optional[str] = None) -> List[RAGOutputItem]:
        """Chunks a single piece of text (either main_text or a structured_element's content)."""
        if not content or len(content.strip()) < self.min_chunk_size:
            return []

        # Naive chunking by character count for now. Can be made more sophisticated.
        text_chunks_content = []
        start = 0
        text_length = len(content)
        while start < text_length:
            end = min(start + self.max_chunk_size, text_length)
            chunk = content[start:end]
            text_chunks_content.append(chunk)
            if end == text_length:
                break
            start = end - self.overlap_size
            if start < 0: start = 0  # Ensure start is not negative after overlap

        output_items = []
        for i, chunk_content_str in enumerate(text_chunks_content):
            if len(chunk_content_str.strip()) < self.min_chunk_size:
                continue

            # Placeholder for entities specific to this chunk.
            # A more advanced system would run NER on each chunk post-splitting.
            chunk_entities = []

            rag_item = self._create_rag_item(
                enriched_item, chunk_content_str,
                chunk_idx=i, total_chunks_for_elem=len(text_chunks_content),
                parent_type=parent_type, parent_element_idx=parent_element_idx,
                element_specific_lang=element_lang,
                element_specific_entities=chunk_entities  # Pass chunk-specific entities if available
            )
            output_items.append(rag_item)
        return output_items

    def chunk_item(self, enriched_item: EnrichedItem) -> List[RAGOutputItem]:
        rag_outputs = []

        # 1. Chunk primary_text_content
        if enriched_item.primary_text_content:
            self.logger.debug(f"Chunking primary_text_content from {enriched_item.source_url}")
            text_chunks = self._chunk_single_content_piece(
                enriched_item.primary_text_content,
                enriched_item,
                parent_type="primary_text",
                element_lang=enriched_item.language_of_primary_text
            )
            rag_outputs.extend(text_chunks)

        # 2. Chunk enriched_structured_elements
        for idx, structured_element in enumerate(enriched_item.enriched_structured_elements):
            element_content = structured_element.get('content')
            element_type = structured_element.get('type', 'unknown_structured_element')
            element_lang_hint = structured_element.get('language')  # Language hint specific to this block

            self.logger.debug(
                f"Chunking structured_element {idx} (type: {element_type}) from {enriched_item.source_url}")

            if element_content:
                element_chunks = self._chunk_single_content_piece(
                    element_content,
                    enriched_item,
                    parent_type=element_type,  # Use the type of the structured block
                    parent_element_idx=idx,
                    element_lang=element_lang_hint  # Pass language hint for this specific element
                )
                rag_outputs.extend(element_chunks)

        if not rag_outputs:
            self.logger.warning(
                f"No RAG output items generated for enriched item ID {enriched_item.id} from {enriched_item.source_url}."
            )
        return rag_outputs
